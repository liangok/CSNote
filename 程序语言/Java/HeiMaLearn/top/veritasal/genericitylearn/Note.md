#泛型类

- \<T>   泛型类标识符--形参类型

    你放进去的类形名相当于实参。
- 泛型类如果没有指定具体的数据类型，此时操作类型时Object
- 泛型类参数只能是类类型，不能是基本数据类型
- 泛型类型在逻辑上可以看作多个不同的类型，但实际上都是形同类型   


#继承

- 子类也是泛型类，子类与父类泛型类型要一致
  
  class ChildGeneric<T> extends Generic<T>
  
- 子类不是泛型类，父类要明确泛型的数据类型

  class ChildGeneric extends Generic<String>


#接口

定义语法：
```
interface 接口名称 <泛型标识，泛型标识，...>{
    泛型标识 方法名();
    ......
}
```

- 实现类不是泛型类，接口要确定数据类型
- 接口也是泛型类，实现类和接口的泛型要一致

#泛型方法

定义语法

```
修饰符 <T, E, ...> 返回值类型 方法名(形参列表){
    方法体...
}
```

- public与返回值中间的<T>非常重要，可以理解为声明此方法为泛型方法
- 只有声明了<T>的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法
- <T>表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T
- 与泛型类的定义一样，此处T可以写为任意标识符，常见的为T, E, K, V的形式的参数常用于表示泛型

#类型通配符

#####"?"通配符
- 类型通配符一般用"?"代替具体实参
- 所以，类型通配符时类型实参，而不是类型形参

#####类型通配符的上限

语法

```
类/接口<? extends 实参类型>
```

- 要求该泛型的类型，只能是实参类型，后实参类型的子类型

#####类型通配符的下限

语法

```
类/接口<? super 实参类型>
```

- 要求改泛型的类型，只能是实参类型，或者实参类型的父类类型

#类型擦除

##### 概念

泛型代码能很好地和之前版本兼容。那是因为，泛型信息只存在于代码编译阶段，在进入JVM之前，于泛型
相关的信息会被擦除，我们成为类型擦除

- 无限制类型擦除
![avatar](https://img-blog.csdnimg.cn/20200321165711898.jpg)
- 有限制类型擦除
![avatar](https://img-blog.csdnimg.cn/20200321170159967.jpg)
- 擦除方法中类型定义的参数
![avatar](https://img-blog.csdnimg.cn/20200321170245514.jpg)
- 桥接方法
![avatar](https://img-blog.csdnimg.cn/20200321165817894.jpg)


#泛型与数组

- 可以声明带泛型的数组引用，但是不能直接创建带泛型的数组对象

- 可以通过java.reflect.Array的newInstance(Class<T>, int n)创建T[]数组


#反射常用的泛型

- Class<T>
- Constructor<T>


