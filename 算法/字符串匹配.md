# 字符串匹配

​	字符串匹配有很多用途，比如使用搜索功能查找文本中的一些文字时，就会用到字符串匹配，除此之外，字符串匹配还可以应用于再DNA中搜索特定序列，再网络搜索引擎中查找网页地址。

​	这里主要介绍四种字符串匹配方法

|算法|预处理时间|匹配时间|
|:--:|:--:|:--:|
|朴素算法|0|$O((n-m+1)m)$|
|Rabin-Karp|$\Theta(m)$|$O((n-m+1)m)$|
|有限自动机算法|$O(m\sum)$|$\Theta(n)$|
|Knuth-Morris-Pratt|$\Theta(m)$|$\Theta(n)$|

​	下面首先定义一些符号，用于更方便和准确的介绍接下来将要讲的内容。

## 符号和术语

​	字符串匹配定义如下：假设文本是一个长度为n的数组$T[1...n]$,而模式时一个长度为m的数组$P[1...m]$,$m\leq n$,进一步假设$P$和$T$的元素都来自于一个有限字母集$\sum$

​	如果$0\leq s\leq n-m$，并且$T[s+1 ... s+m]=P[1...m]$,即$T[s+j]=P[j], 1\leq j\le m$，那么称模式$P$在文本$T$中出现，且偏移量为$s$。如果$P$在$T$中以偏移$s$出现，则称$s$是有效偏移，否则称为无效偏移。而字符串匹配问题就是**找到搜有的有效偏移，使得在该有效偏移下，所给的模式$P$出现在文本$T$中**。

**$\sum ^*$**：包含所有限长度的字符串集合，该字符串由字母表$\sum$中的字符组成。长度为零的空字符串用$\epsilon$表示。

**字符串的长度**：$|x|$

**两个字符串的联结**：$xy$，长度为$|x|+|y|$

**前缀**：对于某个字符串$y\in \sum ^*$有$x=\omega y$，则称字符串$\omega$是字符串$x$的前缀。记作$\omega\sqsubset x$。

**后缀**：对于某个字符串$y\in \sum ^*$有$x=y\omega$，则称字符串$\omega$是字符串$x$的后缀。记作$\omega \sqsupset x$

例如，我们有$ab\sqsubset abcca$和$cca \sqsupset abcca$

>引理1.1（后缀重叠引理）：假设$x,y$和$z$是满足$x\sqsupset z$和$y\sqsupset z$的字符串。如果$|x| \leq |y|$，那么$x\sqsupset y$；如果$|x|\leq |y|$，那么$y\sqsupset x$；如果$|x|=|y|$，那么$x=y$

**$P_k$**:模式$P[1...m]$的由$k$个字符组成的前缀$P[1...k]$，因此$p_0=\epsilon$， $P_m=P=p[1...m]$

采用这种记号，我们能把字符串匹配问题表述为：**找到所有偏移$s(0\leq s\leq n-m)$，使得$p\sqsupset T_{s+m}$**

至此，需要使用的符号就介绍完了，开始正文！



## 朴素字符串匹配算法

这种方法很简单，只需要对所有$n-m+1$个可能的$s$值进行行检测，看是否满足$p[1..m]=T[s+1..s+m]$即可，伪代码如下

```
NAIVE_STRING_MATCHER(T,P)
	n = T.length
	m = P.length
	for s = 0 to n - m
		if P[1..m] == T[s+1..s+m]
			print "Pattern occurs with shift" s
```

## Rabin-Karp算法

​	这个算法在实际使用时可以较好的运行，并且还可以从中归纳出相关问题的其他算法，如二维模式匹配。Rabin-Karp算法的预处理时间是$\Theta(m)$并且在最坏的情况下，它的运行时间是$\Theta((n=m+1)m)$，但是它的平均运行时间还是比较好的。

​	假设$\sum =\{0,1,2,...,9\}$，这样每个字符都是十进制数字。（通常，可假定每个字符都是以$d$为基数表示的数字，其中$d=|\sum |$）。因此，可以用长度为k的十进制数表示由k个连续的字符组成的字符串。如字符串"31415"对应十进制数31415。加入输入的字符既可以看作是图形符号，也可以看作是数字，那么我们会发现在使用Rabin-Karp算法时，用标准文本字体，把它们表示为数字会更方便。

​	给定模式$P[1..m]$，假设$p$表示其相对应的十进制。类似的，给定文本$T[1..n]$，假设$t_s$表示长度$m$的字符串$T[s+1..s+m]$所对应的十进制（$s=0,1,...,n-m$）。因此，只有在$T[s+1..s+m]=P[1..m]$时，$t_s=p$。如果能在$\Theta(m)$时间内计算出$p$的值，并在总时间$\Theta(n-m+1)$内计算出所有的$t_s$值，那么通过比较$p$和每一个$t_s$的值，就可以在$\Theta(m)+\Theta(n-m+1)=\Theta(n)$的时间内找到所有的有效偏移。

可以用霍纳法则在$\Theta(m)$的时间内计算出$p$
$$
p=P[m]+10(P[m-1]+10(P[m-2]+...+10(P[2]+10P[1])...))
$$
类似的，也可以在时间$\Theta(n-m)$时间内根据$T[1..m]$计算出$t_0$的值。

为了在时间$\Theta(n-m)$内计算出剩余的值$t_1,t_2,...,t_{n-m}$，需要在常数时间内根据$t_s$计算出$t_{s+1}$，因为

##### 公式2.1

$$
t_{s+1}=10(t_s-10^{m-1}T[s+1])+T[s+m+1]
$$
​	减去$10^{m-1}T[s+1]$就从$t_s$中去掉了高位数字，再把结果乘以10就使得数字向左移动一个数位，然后加上$T[s+m+1]$，则加入一个适当的底位数字。

#### 时间复杂度

​	如果能预先计算出常数$10^{m-1}$（用31.6节中介绍的技术就可以在$O(log_2m)$的时间内完成这一计算过程，但对于这个应用，一种简便的运行时间为$O(m)$的算法就足够完成任务），则每次执行公式2.1的时间，需要执行的算数运算的次数为常数。因此，可以在$\Theta(m)$的时间内计算出$p$，在时间$\Theta(n-m+1)$内计算出所有$t_0,t_1,t_2,...,t_{n-m}$的值，因此可以用$\Theta(m)$的预处理时间和$\Theta(n-m+1)$的匹配时间找所有模式$P[1..m]$在文本$T[1..n]$中可能出现的位置。

​	到目前为止都假设$p$，和$t_s$的值并不是太大，因为如果太大，导致不能方便的对其进行操作。假设$P$包含包含$m$个字符，那么关于在$p$（$m$位长）上每次算数时间需要常数时间这一假设就不成立。

#### $P$较大时的解决方法

​	选取一个合适的模$q$来计算$p$和$t_s$的模。我们可以在$\Theta(m)$的时间内计算出模$q$的$p$值，并可以在$\Theta(n-m+1)$时间内计算出模$q$的所有$t_s$值。如果选模$q$为一个素数，使得$10q$恰好满足一个计算机字长，那么可以用单精度算数运算执行所有必须的运算。在一般情况下，采用$d$进制的字母表${0,1,...,d-1}$时，选取一个$q$值，使得$dq$在一个计算机字长内，然后调整递归式2.1，使其能够对模$q$有效

##### 公式2.2

$$
t_{s+1}=(d(t_s-T[s+1]h)+T[s+m+1])\mod q
$$

其中$h\equiv d^{m-1}(\mod q)$是一个具有$m$数位的文本窗口的高位数位上的数字“1”的值

​	可以发现这种方式会出现“伪命中点”，$t\equiv p(\mod q)$并不能说明$t_s=p$，但是如果$t_s\neq p(\mod q)$，那么可以断定$t_s\neq p$，从而确定偏移$s$是无效的，因此还需要进一步的进行检测，可以通过检测条件$P[1..m]=T[s+1.s+m]$来完成，如果$q$足够大，那么伪命中点就可以尽量少出现。

我们用下面的过程表示，其中输入文本是$T$，模式$P$，使用基数$d$（其典型取值为$| \sum|$）和素数$q$。

```
RABIN_KARP_MATCHER(T,P,d,q)
	n = T.length
	m = P.length
	h = d ^ (m-1) mod q
	p = 0
	t_0 = 0
	for i = 1 to n	//preprocessing
		p = (d * p + P[i]) mod q
	for s = 0 to n - m
		if p == t_s
			if P[1..m] == T[s+1..s+m]
				print "Pattern occurs with shift" s
		if s < n - m
			t_{s+1} = (d(t_s - T[s+1] * h) + T[s+m+1]) mod q
```

​	在许多实际应用中，我们希望有效偏移的个数少一点（如只有常数$c$个）。在这样的应用中，加上处理伪命中点所需的时间，算法的期望匹配时间为$O((n-m+1)+cm)=O(n+m)$。减少模$q$的值就如同从$\sum^*$到$Z_q$上的一个随机映射，因此也可以用散列除法。

## 利用有限自动机进行字符串匹配

这部分内容理解的还不是特别透彻，故先不写。



## Knuth-Morris-Pratt算法

​	Knuth-Morris-Pratt算法又简称KMP算法，这种算法无须计算转移函数，只需$O(n)$的时间进行匹配，其中需要用到辅助函数$\pi$，而辅助函数可以在$\Theta(m)$的时间内计算出来，并存储在数组$\pi[1..m]$中。数组$\pi$使得我们可以按需要“即时”的有效计算转移函数$\delta$。粗略的说，对于任意状态$q=0, 1, ...,m$和任意字符$a\in \sum$，$\pi[p]$的值包含了与$a$无关但在计算$\delta(q,a)$时需要的信息。由于数组$\pi$只有$m$个元素，而$\delta$由$\Theta(m|\sum|)$个值，所以通过预先计算$\pi$而不是$\delta$，可以使计算少一个$\sum$因子。

### $\pi$数组的求法

​	首先考虑一下朴素算法，如果前5个字符都已经配对成功，但是第6个字符无法匹配，但是已经匹配的5个字符可以让我们确定有些偏移使无效的。通常的，在一般情况下，直到下列问题的答案将是很有用的。

#### 4.1

假设模式字符$P[1..q]$与文本字符$T[s+1..s+q]$匹配，$s'$是最小的偏移量，$s'>s$，那么对于某些$k<q$，满足


$$
P[1..k]=T[s'+1..s'+k]
$$
的最小偏移$s'>s$是多少，其中$s'+k=s+q$？

```
index:  0  1  2  3  4  5  6  7  8  9  10 11 12 13
    T:  a  b  a  c  d  s  d  q  b  s  d  q  c  p
    P:                 s  d  q  b  s  d  q  ?

//分析
s=5, q=7
接下来想要找到一个s'，使得无需把P的前k个字符与T中相应的字符进行比较，就可以保证是对应的。
k=3, s'= s + (q - k) = 5 + (7 - 3) = 9
这样可以直接对应到第9个的's'上
s' + k = 12, 对应'c'直接从'c'开始下一次判断。
```



​	换句话说，已知$P_q\sqsupset T_{s+q}$，我们希望$P_q$的最长真前缀$P_k$也是$T_{s+1}$的后缀。（由于$s'+k=s+q$，所以，如果给出$s$，$q$，那么找到最小偏移量$s'$等价于找到最长前缀的长度$k$，也就是$s'=s+(q-k)$。）

最好情况下，$k=0$，因此$s'=s+q$，并且可直接得到偏移$s+1,s+2,...,s+q-1$。

​	因此，**在任何情况下，对于新的偏移$s'$，无需把$P$的前$k$个字符与$T$中相应的字符进行比较，因为等式(4.1)已经保证它们肯定匹配。**

​	可以利用模式与其自身进行比较来预先计算出这些必要的信息。由于$T[s'+1..s'+k]$是文本中已经知道的部分，所以它是字符串$P_q$的一个后缀。可以把等式（4.1）解释为要求满足$P_k\sqsupset P_q$的最大的$k<q$。于是，这个新的偏移$s'=s+(q+k)$就是下一个可能的有效偏移。可以发现，对于每一个$q$值，把已匹配字符数目$k$存储在新的偏移$s'$（而不是$s'-s$）中是比较方便的。

下面是预计算过程的形式化说明。已知一个模式$P[1..m]$，模式$P$的前缀数是函数$\pi:\{1,2,...,m\}\rightarrow \{0,1,...,m-1\}$，满足
$$
\pi[q]=max\{k:k<q 且 P_k\sqsupset P_q\}
$$
代码如下(这里的Next()函数就是上面说到的$\pi$)

```c
int* Next(char *p, int pl)
{
    int* next;
    next = (int *)malloc(sizeof(int) * pl);
    next[0] = 0;
    int k = 0;
    for(int q = 1; q < pl; q++){
        while(k > 0 && p[k] != p[q]){
            k = next[k - 1];
        }
        if(p[k] == p[q]){
            k++;
        }
        next[q] = k;
    }

    return next;
}
```

```c
void KMP(char *t, char *p, int tl, int pl)
{
    int *next = Next(p, pl);
    int q = 0;  //numbers of characters matched
    for(int i = 0; i < tl; i++){
        while(q > 0 && p[q] != t[i]){
            q = next[q - 1];
        }
        if(p[q] == t[i]){
            q++;
        }
        if(q == pl){
            printf("Pattern occurs with shift %d\n", i - pl + 2);
            q = next[q];
        }
    }
}
```

