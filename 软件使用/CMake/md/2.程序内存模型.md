# 内存管理基础

## 程序内存模型

* 静态常量区
* 调用栈
* 堆

### 静态常量区

* 只读
* 大小固定
* 无法管理
* 可以利用其特性在逻辑上做一些特定的优化（对新手不友好，暂时不讲解）

### 调用栈

* 被动分配，被动回收
* 大小在运行期有一个动态调整的过程
* 大小有系统限制
* 底大顶小

1. 为什么变量有作用域？
2. 为什么不建议使用递归？

> 先进后出，轮流使用

> 不要在函数体内声明大块内存（数组，大型结构体）

### 堆

* 堆大小较大（甚至可以申请直到内存消耗完）
* 主动分配 主动回收

分配方式 | 回收方式
-|-
malloc/calloc | free
new | delete
new T[] | delete []T

示例：

```cpp
void * mem = malloc(1024); // c 风格 分配方式1
void * mem = calloc(1024); // c 风格 分配方式2
free(mem);                 // c 风格 回收内存

int* iptr = new int;       // cpp new
delete iptr;               // cpp delete

int* iarrptr = new int[1024];  // cpp new[]
delete[] iarrptr;              // cpp delete[]

```

* 一直申请不回收会发生什么？
* 拿到内存后不要访问超过你申请的量
* 导致 undefined behavior ( 未定义行为 )

> 1.有借有还，再借不难
> 2.不要挑战语言规则

## 指针

什么是指针？

为方便理解，可以这么解释，指针是表示某块数据在内存中的地址，地址为整形，它能表示的范围因平台不同而不同。

程序类型|指针位数|等同于
-|-|-
32位程序|32|uint32_t
64位程序|64|uint64_t

在同一平台上，一般而言，任何一个指针类型都可以退化为整数表示，所以任何指针的本质都是一个整数，它代表着一个内存位置。

代码演示：

指针，指向指针的指针，指向指针的指针的指针？？？

小红，小明，小华，捡到一块钱的故事。

## 结构体 & 类 的 数据成员 布局

* 拓展到数组 以及 二维数组

## 再谈UNION



## 类/结构体 的内存布局

* 数据成员
* 虚函数表指针

